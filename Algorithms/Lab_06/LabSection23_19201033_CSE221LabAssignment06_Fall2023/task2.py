# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15HAIdkL4KT9rGVR_IKpK3eWYrI8qLdz3
"""



# Shortest path  with adjacency list
from queue import PriorityQueue


def dijkstra(source, dist, nodes):
    # make all distance to infinity or large number
    for i in range(1, nodes+1):
        dist[i] = 1e9 + 10

    # make source distance 0
    dist[source] = 0

    pq = PriorityQueue()

    pq.put((0, source))  #(cost, node)

    while not pq.empty():
        pair = pq.get()
        cost = pair[0]
        u = pair[1]

        if dist[u] != cost:
            continue

        for adj_pair in adj_lst[u]:
            adj_cost = adj_pair[0]
            adj_node = adj_pair[1]

            if cost + adj_cost < dist[adj_node]:
                dist[adj_node] = cost + adj_cost
                pq.put((dist[adj_node], adj_node))


#-----------------------------------------------------
input = open("/content/input2.txt", 'r')
output = open("/content/output2.txt", 'w')

nodes, edges = map(int, input.readline().split())

adj_lst = [[] for i in range(nodes+1)]
dist1 = [0] * (nodes+1)
dist2 = [0] * (nodes+1)

# Taking the edges with cost
for i in range(edges):
    u, v, cost = map(int, input.readline().split())
    # For directed graph
    adj_lst[u].append((cost, v))

source1, source2 = map(int, input.readline().split())


dijkstra(source1, dist1, nodes)
dijkstra(source2, dist2, nodes)

time = 1e9
node = 0

for n in range(1, nodes+1):
  if dist1[n] != 1e9+10 and dist2[n] != 1e9+10:
    t = max(dist1[n], dist2[n])
    if t < time:
      time = t
      node = n

if time == 1e9:
  print(f"Impossible", end = "", file=output)
else:
  print(f"Time: {time}\nNode: {node}", end = "", file=output)

input.close()
output.close()