# -*- coding: utf-8 -*-
"""task1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15HAIdkL4KT9rGVR_IKpK3eWYrI8qLdz3
"""



# Shortest path  with adjacency list
from queue import PriorityQueue


def dijkstra(source,dist, nodes):
    # make all distance to infinity or large number
    for i in range(1, nodes+1):
        dist[i] = 1e9 + 10

    # make source distance 0
    dist[source] = 0

    pq = PriorityQueue()

    pq.put((0, source))  #(cost, node)

    while not pq.empty():
        pair = pq.get()
        cost = pair[0]
        u = pair[1]

        if dist[u] != cost:
            continue

        for adj_pair in adj_lst[u]:
            adj_cost = adj_pair[0]
            adj_node = adj_pair[1]

            if cost + adj_cost < dist[adj_node]:
                dist[adj_node] = cost + adj_cost
                pq.put((dist[adj_node], adj_node))


#-----------------------------------------------------
input = open("/content/input1.txt", 'r')
output = open("/content/output1.txt", 'w')
nodes, edges = map(int, input.readline().split())

adj_lst = [[] for i in range(nodes+1)]
dist = [0] * (nodes+1)

# Taking the edges with cost
for i in range(edges):
    u, v, cost = map(int, input.readline().split())
    # For directed graph
    adj_lst[u].append((cost, v))

source = int(input.readline().strip())


dijkstra(source, dist, nodes)


for v in range(1, nodes+1):
  if dist[v] == 1e9+10:
    print(f"-1", end=" ", file = output)
  else:
    print(f"{dist[v]}", end=" ", file = output)

input.close()
output.close()